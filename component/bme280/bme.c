/**
 * @file bme.c (Library)
 * @author Trương Quốc Ánh (you@domain.com)
 * @brief bme's library
 * @version 0.2
 * @date 2023-12-14
 * 
 * @copyright Copyright (c) 2023
 */
#include "bme280.h"
#include "bme.h"

#include <stdio.h>

#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

#include "sdkconfig.h"  /** Generated by "make menuconfig" */   


void i2c_master_bme_init(int SDA_PIN, int SCL_PIN)
{
    /** I2C config, include mode, pin for I2C protocol, pull-up resistor and I2C frequency */
    i2c_config_t i2c_config  =
    {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = SDA_PIN,
        .scl_io_num = SCL_PIN,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = 1000000,
    };
    /** After set config, we initialize  i2c for particular port.
     *  @param 1: I2C port
     * @param 2: pointer of constant configuration structure of type i2c_config_t (upper structure) 
    */
    i2c_param_config(I2C_NUM_0, &i2c_config);
    /**
     * @brief Install i2c driver.
     * @param 1,2 : I2C port and mode
     * @param 3,4,5: Rx and Tx buffer. And the last used for interrupt. value "0" means that we don't use buffer here
     */
    i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
}
/**
 * @brief Write bus BME280 I2C
 * @note typedef	int8_t s8;  <used for signed 8bit>   (Regulated in BME28.h)  
 * @note typedef	u_int8_t u8; < used for unsigned 8bit > (Regulated in BME28.h) 
 * @param dev_addr : The device address of the sensor  (slave)
 * @param reg_addr : Address of the first register, will data is going to be written
 * @param reg_data : It is a value hold in the array,
 *	will be used for write the value into the register
 *	@param cnt : The number of byte of data to be write
 * @return s8 
 */
// s8 BME280_I2C_bus_write (u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
// {
//     s32 iError = BME280_INIT_VALUE;

//     esp_err_t espRc;
//     /** 
//      * @brief: Create and initialize an I2C commands list with a given buffer. After finishing the I2C transactions, 
//      * it is required to call i2c_cmd_link_delete() to release and return the resources. The required bytes will be dynamically allocated.
//      * @return Handle to the I2C command link or NULL in case of insufficient dynamic memory.

//      */
//     i2c_cmd_handle_t cmd = i2c_cmd_link_create();
//     /** 
//      * @brief: Let i2c master initialize system signals. Queue a "START signal" to the given commands list.
//      * @note:  Call i2c_master_cmd_begin() to send all the queued commands.
//      * * @attention: This function will be called ONLY the device is master */
//     i2c_master_start(cmd);
//     /**
//      * @brief This code line means Master send a bit data by I2C to slave (dev_address) (Write to the command list first). 
//      * After sending, an ACK signal will be sent to confirm the device receives data successfully 
//      * @param 1: I2C command list, in this case is "cmd", which have just been initialized before
//      * @param 2: Data to send on Port. In This Case is "(dev_addr << 1) | I2C_MASTER_WRITE"
//      * @note (Đoạn này viết tiếng Việt vì viết tiếng Anh khó quá =))) ). Đầu tiên là cụm (dev_addr<<1). Là dịch trái 1 bit của cái địa chỉ device. Điều 
//      * này xảy ra là do địa chỉ được lưu ở dạng 8 bit (u8) nhưng trong quy định của I2C nó chỉ lấy 7 bit thôi. Do đó khi ta dịch trái 1 bit rồi lại lấy đi 1 
//      * bit thấp nhất thì không ảnh hưởng đến giá trị của nó. cái giá trị của I2C_MASTER_WRITE kia được quy định là 0 (thì bằng 0 thằng slave nó mới nhận dữ liệu 
//      * mà.)Tóm lại, nó sẽ gửi 7 bit địa chỉ slave và 1 bit chỉ hướng truyền (đỷ 1 byte)
//      * @param 3: use ACK to check
//      */
//     i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);

//     /** Queue a " Write byte " to the command list. this "write byte " means Sending  address of register which will be used to contain data */
//     i2c_master_write_byte(cmd, reg_addr, true);
//     /**  
//      * @brief: Write the buffer to the I2C bus. (Queue a " Write byte " to the command list)
//      * @param 1: I2C command list ("cmd" in this case)
//      * @param 2: Data
//      * @param 3: data-len ("cnt" in this case)
//      * @param 4: use ACK to check
//     */
//     i2c_master_write(cmd, reg_data, cnt, true);
//     /** Queue a "STOP signal" to the given commands list. */
//     i2c_master_stop(cmd);
//     /** 
//      * @brief When every queued commands we need is on I2C bus, we start to send it. All other Tasks will be blocked until last command sent.
//      * This I2C port will be protected by Mutex.
//      * @return: Error Code (if any)
//      */
//     espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
//     if (espRc == ESP_OK)
//     {
//         iError = SUCCESS;
//     }
//     else 
//     {
//         iError = ERROR;
//     }
//     /**
//      * @brief Construct a new i2c cmd link delete object. (REQUIRED AFTER CREATE)
//      * @param: variable save data of the i2c's link 
//      */
//     i2c_cmd_link_delete(cmd);
//     return (s8)iError; 
// }

/**
 * @brief This function is same with the above function, but have same differences between write and read 
 * 
 * @param dev_addr 
 * @param reg_addr 
 * @param reg_data 
 * @param cnt 
 * @return s8 
 */
s8 BME280_I2C_bus_write (u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
{
    s32 iError = BME280_INIT_VALUE;

    esp_err_t espRc;
    /** 
     * @brief: Create and initialize an I2C commands list with a given buffer. After finishing the I2C transactions, 
     * it is required to call i2c_cmd_link_delete() to release and return the resources. The required bytes will be dynamically allocated.
     * @return Handle to the I2C command link or NULL in case of insufficient dynamic memory.

     */
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    /** 
     * @brief: Let i2c master initialize system signals. Queue a "START signal" to the given commands list.
     * @note:  Call i2c_master_cmd_begin() to send all the queued commands.
     * * @attention: This function will be called ONLY the device is master */
    i2c_master_start(cmd);
    /**
     * @brief This code line means Master send a bit data by I2C to slave (dev_address) (Write to the command list first). 
     * After sending, an ACK signal will be sent to confirm the device receives data successfully 
     * @param 1: I2C command list, in this case is "cmd", which have just been initialized before
     * @param 2: Data to send on Port. In This Case is "(dev_addr << 1) | I2C_MASTER_WRITE"
     * @note (Đoạn này viết tiếng Việt vì viết tiếng Anh khó quá =))) ). Đầu tiên là cụm (dev_addr<<1). Là dịch trái 1 bit của cái địa chỉ device. Điều 
     * này xảy ra là do địa chỉ được lưu ở dạng 8 bit (u8) nhưng trong quy định của I2C nó chỉ lấy 7 bit thôi. Do đó khi ta dịch trái 1 bit rồi lại lấy đi 1 
     * bit thấp nhất thì không ảnh hưởng đến giá trị của nó. cái giá trị của I2C_MASTER_WRITE kia được quy định là 0 (thì bằng 0 thằng slave nó mới nhận dữ liệu 
     * mà.)Tóm lại, nó sẽ gửi 7 bit địa chỉ slave và 1 bit chỉ hướng truyền (đỷ 1 byte)
     * @param 3: use ACK to check
     */
    i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);

    /** Queue a " Write byte " to the command list. this "write byte " means Sending  address of register which will be used to contain data */
    i2c_master_write_byte(cmd, reg_addr, true);
    /**  
     * @brief: Write the buffer to the I2C bus. (Queue a " Write byte " to the command list)
     * @param 1: I2C command list ("cmd" in this case)
     * @param 2: Data
     * @param 3: data-len ("cnt" in this case)
     * @param 4: use ACK to check
    */
    i2c_master_write(cmd, reg_data, cnt, true);
    /** Queue a "STOP signal" to the given commands list. */
    i2c_master_stop(cmd);
    /** 
     * @brief When every queued commands we need is on I2C bus, we start to send it. All other Tasks will be blocked until last command sent.
     * This I2C port will be protected by Mutex.
     * @return: Error Code (if any)
     */
    espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    if (espRc == ESP_OK)
    {
        iError = SUCCESS;
    }
    else 
    {
        iError = ERROR;
    }
    /**
     * @brief Construct a new i2c cmd link delete object. (REQUIRED AFTER CREATE)
     * @param: variable save data of the i2c's link 
     */
    i2c_cmd_link_delete(cmd);
    return (s8)iError; 
}
/**
 * @brief This function is same with the above function, but have same differences between write and read 
 * 
 * @param dev_addr 
 * @param reg_addr 
 * @param reg_data 
 * @param cnt 
 * @return s8 
 */

s8 BME280_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8*reg_data, u8 cnt)
{
    s32 iError = BME280_INIT_VALUE;
    esp_err_t espRc;

    i2c_cmd_handle_t cmd = i2c_cmd_link_create();

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (dev_addr <<1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg_addr, true);
    /** 
     * @brief In above Functions, after send register address, we use write command to write data to register. But on this Read function
     * we use reading command instead of writing command
     */
    i2c_master_start(cmd);
    /**
     * @brief Like what i've  explain above, in this case we use Or operator (Expands for 1). That make sure the last bit is 1. This help 
     * address pin is on Reading mode
     */
    i2c_master_write_byte(cmd, (dev_addr <<1) | I2C_MASTER_READ, true);

    if (cnt > 1)
    {
    /**
     * @brief Queue a "reading commands". This command make  Multiple bytes will be read on the I2C bus
     * @param 1: Command list
     * @param 2: Data saved on Register
     * @param 3: Data-len. We Need to -1 because I2C_MASTER_ACK will make slave send a confirm bit to make sure master receive bit successfully. And after confirming
     * master will continue receive next bit. So we need to -1 to help master receive last bit.
     * @param 4: Use ACK to confirm
     */

        i2c_master_read(cmd, reg_data, cnt - 1, I2C_MASTER_ACK);
    }
    /** Read last bit as I explain above */
    i2c_master_read_byte(cmd, reg_data + cnt - 1 , I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    
    espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    if (espRc == ESP_OK)
    {
        iError = SUCCESS;
    }
    else
    {
        iError = ERROR;
    }
    i2c_cmd_link_delete(cmd);
    
    return (s8)iError;

}

void BME280_delay_msek (u32 msek)
{
    vTaskDelay(msek/portTICK_PERIOD_MS);
}

/** Read form BME and Display on screen */
void bme280_reader_task (void *ignore)
{
    /** Struct of BME280. In contain  Writing and Reading from BME, address of slave (BME ) and Delay */
    struct bme280_t bme280 =
    {
        .bus_write = BME280_I2C_bus_write,
        .bus_read = BME280_I2C_bus_read,
        .dev_addr = BME280_I2C_ADDRESS1,
        .delay_msec = BME280_delay_msek
    };
    /** Declare variable   */
    s32 com_rslt;
    s32 v_uncomp_pressure_s32;
    s32 v_uncomp_temperature_s32;
    s32 v_uncomp_humidity_s32;
    /**Initialize Bme280 sensor */
    com_rslt = bme280_init(&bme280);
    /** Read Data of pressure Written on Register 
     *  the value of the pressure over sampling. It can take any value listed below:

Skipped: value is 0x00
BME280_OVERSAMP_1X: Value is 0x01
BME280_OVERSAMP_2X: Value is 0x02
BME280_OVERSAMP_4X: Value is 0x03
BME280_OVERSAMP_8X: Value is 0x04
BME280_OVERSAMP_16X: Value is 0x05, 0x06 and 0x07
    */
    com_rslt += bme280_set_oversamp_pressure(BME280_OVERSAMP_16X);
    com_rslt += bme280_set_oversamp_temperature(BME280_OVERSAMP_2X);
    com_rslt += bme280_set_oversamp_humidity(BME280_OVERSAMP_1X);
    /**
     * @brief After that we will write the standby duration time from the sensor in the register 0xF5 bit 5 to 7 by calling bme280_set_standby_durn(). This function takes in a single parameter which is the value of the standby duration time. It can take any value listed below:

BME280_STANDBY_TIME_1_MS
BME280_STANDBY_TIME_63_MS
BME280_STANDBY_TIME_125_MS
BME280_STANDBY_TIME_250_MS
BME280_STANDBY_TIME_500_MS
BME280_STANDBY_TIME_1000_MS
BME280_STANDBY_TIME_2000_MS
BME280_STANDBY_TIME_4000_MS
     * 
     */
    com_rslt += bme280_set_standby_durn(BME280_STANDBY_TIME_1_MS);
    com_rslt += bme280_set_filter(BME280_FILTER_COEFF_16);
    /** Set power mode  */
    com_rslt += bme280_set_power_mode(BME280_NORMAL_MODE);

    if (com_rslt == SUCCESS)
    {
        /** Start infinite loop to reads and prints data on screen */
        while(true)
        {
            vTaskDelay(40/portTICK_PERIOD_MS);
            /**
             * @brief This function takes in three parameters which are the value of the uncompensated pressure, temperature and humidity respectively.
             */
            com_rslt = bme280_read_uncomp_pressure_temperature_humidity(&v_uncomp_pressure_s32, &v_uncomp_temperature_s32, &v_uncomp_humidity_s32); 

            if (com_rslt == SUCCESS)
            {
                ESP_LOGI(__func__, "%.2f degC / %.3f hPa / %.3f %%", 
                /**The bme280_compensate_temperature_double() outputs the actual temperature from uncompensated temperature */
                bme280_compensate_temperature_double(v_uncomp_temperature_s32),
                /**The bme280_compensate_pressure_double() outputs the actual pressure from the uncompensated pressure. */
                bme280_compensate_pressure_double(v_uncomp_pressure_s32)/100,   /**Pa -> hPa */
                /**Similarly, the bme280_compensate_humidity_double() outputs the actual humidity from the uncompensated humidity. */
                bme280_compensate_humidity_double(v_uncomp_humidity_s32)
                );
            }
        }
    }
    else 
            {
                ESP_LOGE(TAG_BME280, "measure error. code: %d \n", com_rslt);
            }
    vTaskDelete(NULL);
}

